<#
Remove-LockedMalware.ps1
Usage as Admin:
  PowerShell -ExecutionPolicy Bypass -File .\Remove-LockedMalware.ps1 -TargetPath "C:\Users\Mohamed\Downloads\Temp\dllhost.exe"
#>

param(
    [Parameter(Mandatory=$true)]
    [string] $TargetPath
)

function Log { param($m) Write-Host "[*] $m" }

# 1) Check for administrative privileges
$principal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Log "This script must be run as Administrator."
    exit 1
}

# 2) Resolve the full path of the target file
try {
    $resolved = Resolve-Path -LiteralPath $TargetPath -ErrorAction Stop
    $TargetPath = $resolved.ProviderPath
} catch {
    Log "The target path does not exist: $TargetPath"
    exit 1
}
Log "Target file = $TargetPath"

# 3) Do not touch the legitimate system dllhost.exe
$sysDll = "$env:windir\System32\dllhost.exe"
if ([string]::Compare($TargetPath, $sysDll, $true) -eq 0) {
    Log "Refusing to modify the legitimate system dllhost.exe in System32."
    exit 1
}

# 4) Find processes using the target file
$fileName = [IO.Path]::GetFileName($TargetPath)
$found = @()

try {
    # First, try to find processes by exact ExecutablePath
    $found += Get-CimInstance Win32_Process -Filter ("ExecutablePath = '{0}'" -f $TargetPath.Replace("'", "''")) -ErrorAction SilentlyContinue
} catch {}

if (-not $found) {
    # Broader search: look for filename in CommandLine
    try {
        $found += Get-CimInstance Win32_Process | Where-Object { $_.CommandLine -and $_.CommandLine.IndexOf($fileName, [StringComparison]::InvariantCultureIgnoreCase) -ge 0 }
    } catch {}
}

if ($found) {
    foreach ($p in $found | Select-Object -Unique) {
        Log "Found process PID=$($p.ProcessId) Name=$($p.Name). Attempting to stop..."
        try {
            Stop-Process -Id $p.ProcessId -Force -ErrorAction Stop
            Log "Stopped process PID=$($p.ProcessId)."
        } catch {
            Log "Failed to stop PID=$($p.ProcessId): $_"
        }
    }
} else {
    Log "No processes found that clearly reference the target file."
}

Start-Sleep -Milliseconds 500

# 5) Take ownership and grant Administrators full control
try {
    & takeown.exe /f "$TargetPath" /a | Out-Null
    & icacls.exe "$TargetPath" /grant Administrators`:(F) /c | Out-Null
    Log "Ownership and permissions updated (if possible)."
} catch {
    Log "Failed to change ownership/permissions: $_"
}

# 6) Remove read-only, hidden, and system attributes
try { attrib -s -h -r "$TargetPath" 2>$null } catch {}

# 7) Attempt immediate deletion
$deleted = $false
try {
    Remove-Item -LiteralPath $TargetPath -Force -ErrorAction Stop
    Log "File deleted successfully."
    $deleted = $true
} catch {
    Log "Immediate deletion failed: $_"
}

# 8) If deletion failed, schedule deletion on next reboot
if (-not $deleted) {
    Log "Scheduling deletion on next reboot..."
    $regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager"
    $valueName = "PendingFileRenameOperations"
    $src = "\\??\\$TargetPath"
    try {
        $existing = (Get-ItemProperty -Path $regPath -Name $valueName -ErrorAction SilentlyContinue).$valueName
    } catch { $existing = $null }

    if ($existing) {
        $new = @()
        $new += $existing
        $new += $src
        $new += ""
    } else {
        $new = @($src, "")
    }
    try {
        New-ItemProperty -Path $regPath -Name $valueName -PropertyType MultiString -Value $new -Force | Out-Null
        Log "File scheduled for deletion on next boot. Please restart your computer."
    } catch {
        Log "Failed to schedule deletion in the registry: $_"
    }
}

Log "Script completed. After deletion or reboot, run a full antivirus scan (Windows Defender / Malwarebytes) and check the registry for any remaining entries."
