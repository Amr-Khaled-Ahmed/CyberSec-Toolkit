import subprocess
import threading
import time
import json
import psutil
import frida
import os
import signal
import logging
from datetime import datetime
from mitmproxy.tools.dump import DumpMaster
from mitmproxy import options, http
from mitmproxy.addons import core
from typing import List, Dict, Any

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('malware_analysis.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnhancedReport:
    def __init__(self):
        self.data = {
            "metadata": {
                "analysis_start": datetime.now().isoformat(),
                "analysis_duration": None,
                "malware_path": None,
                "system_info": self._get_system_info()
            },
            "network": {
                "urls_accessed": [],
                "dns_queries": [],
                "http_requests": [],
                "https_requests": []
            },
            "system": {
                "api_calls": [],
                "created_files": [],
                "registry_operations": [],
                "process_operations": []
            },
            "process_tree": [],
            "artifacts": []
        }

    def _get_system_info(self) -> Dict[str, Any]:
        """Collect basic system information"""
        return {
            "platform": os.name,
            "system": os.uname().sysname if hasattr(os, 'uname') else None,
            "release": os.uname().release if hasattr(os, 'uname') else None,
            "cpu_count": os.cpu_count(),
            "memory": psutil.virtual_memory()._asdict()
        }

    def finalize(self) -> None:
        """Finalize the report with end time and duration"""
        end_time = datetime.now()
        start_time = datetime.fromisoformat(self.data["metadata"]["analysis_start"])
        self.data["metadata"]["analysis_end"] = end_time.isoformat()
        self.data["metadata"]["analysis_duration"] = str(end_time - start_time)

    def save(self, filename: str = "report.json") -> None:
        """Save the report to a file"""
        self.finalize()
        with open(filename, "w") as f:
            json.dump(self.data, f, indent=4)
        logger.info(f"Report saved to {filename}")

    def add_network_activity(self, activity_type: str, data: Dict[str, Any]) -> None:
        """Add network activity to the report"""
        if activity_type in self.data["network"]:
            self.data["network"][activity_type].append(data)
        else:
            logger.warning(f"Unknown network activity type: {activity_type}")

    def add_system_activity(self, activity_type: str, data: Dict[str, Any]) -> None:
        """Add system activity to the report"""
        if activity_type in self.data["system"]:
            self.data["system"][activity_type].append(data)
        else:
            logger.warning(f"Unknown system activity type: {activity_type}")

    def set_malware_path(self, path: str) -> None:
        """Set the malware path in the report"""
        self.data["metadata"]["malware_path"] = os.path.abspath(path)

    def add_process_tree(self, processes: List[Dict[str, Any]]) -> None:
        """Add process tree information to the report"""
        self.data["process_tree"] = processes

    def add_artifact(self, artifact_type: str, data: Dict[str, Any]) -> None:
        """Add collected artifacts to the report"""
        self.data["artifacts"].append({
            "type": artifact_type,
            "data": data,
            "timestamp": datetime.now().isoformat()
        })

REPORT = EnhancedReport()

class EnhancedProxy:
    def __init__(self):
        self.dns_cache = {}

    def request(self, flow: http.HTTPFlow) -> None:
        """Handle HTTP requests"""
        url = flow.request.pretty_url
        request_data = {
            "url": url,
            "method": flow.request.method,
            "headers": dict(flow.request.headers),
            "timestamp": datetime.now().isoformat()
        }

        if flow.request.scheme == "https":
            REPORT.add_network_activity("https_requests", request_data)
        else:
            REPORT.add_network_activity("http_requests", request_data)

        logger.info(f"[Network] {flow.request.method} {url}")

    def response(self, flow: http.HTTPFlow) -> None:
        """Handle HTTP responses"""
        if flow.response:
            response_data = {
                "url": flow.request.pretty_url,
                "status_code": flow.response.status_code,
                "headers": dict(flow.response.headers),
                "timestamp": datetime.now().isoformat()
            }
            REPORT.add_artifact("http_response", response_data)

    def dns_response(self, flow: http.DNSFlow) -> None:
        """Handle DNS responses"""
        if flow.response:
            for answer in flow.response.answers:
                dns_data = {
                    "query": answer.name,
                    "response": answer.ipv4 if hasattr(answer, 'ipv4') else answer.ipv6,
                    "type": "A" if hasattr(answer, 'ipv4') else "AAAA",
                    "timestamp": datetime.now().isoformat()
                }
                REPORT.add_network_activity("dns_queries", dns_data)
                logger.info(f"[DNS] {answer.name} -> {dns_data['response']}")

def run_mitmproxy() -> None:
    """Run the mitmproxy in a separate thread"""
    try:
        opts = options.Options(
            listen_host="127.0.0.1",
            listen_port=8080,
            ssl_insecure=True,
            showhost=True
        )
        m = DumpMaster(opts, with_termlog=False, with_dumper=False)
        m.addons.add(core.Core())
        m.addons.add(EnhancedProxy())
        
        logger.info("Starting mitmproxy on 127.0.0.1:8080")
        m.run()
    except Exception as e:
        logger.error(f"mitmproxy error: {e}")
    finally:
        logger.info("mitmproxy stopped")

FRIDA_SCRIPT = """
const INTERESTING_APIS = {
    "File Operations": [
        ["kernel32.dll", "CreateFileW", ["lpFileName", "dwDesiredAccess", "dwShareMode", "lpSecurityAttributes", "dwCreationDisposition", "dwFlagsAndAttributes", "hTemplateFile"]],
        ["kernel32.dll", "WriteFile", ["hFile", "lpBuffer", "nNumberOfBytesToWrite", "lpNumberOfBytesWritten", "lpOverlapped"]],
        ["kernel32.dll", "DeleteFileW", ["lpFileName"]]
    ],
    "Process Operations": [
        ["kernel32.dll", "CreateProcessW", ["lpApplicationName", "lpCommandLine", "lpProcessAttributes", "lpThreadAttributes", "bInheritHandles", "dwCreationFlags", "lpEnvironment", "lpCurrentDirectory", "lpStartupInfo", "lpProcessInformation"]],
        ["kernel32.dll", "CreateRemoteThread", ["hProcess", "lpThreadAttributes", "dwStackSize", "lpStartAddress", "lpParameter", "dwCreationFlags", "lpThreadId"]]
    ],
    "Network Operations": [
        ["wininet.dll", "InternetOpenW", ["lpszAgent", "dwAccessType", "lpszProxy", "lpszProxyBypass", "dwFlags"]],
        ["wininet.dll", "InternetOpenUrlW", ["hInternet", "lpszUrl", "lpszHeaders", "dwHeadersLength", "dwFlags", "dwContext"]]
    ],
    "Registry Operations": [
        ["advapi32.dll", "RegCreateKeyExW", ["hKey", "lpSubKey", "Reserved", "lpClass", "dwOptions", "samDesired", "lpSecurityAttributes", "phkResult", "lpdwDisposition"]],
        ["advapi32.dll", "RegSetValueExW", ["hKey", "lpValueName", "Reserved", "dwType", "lpData", "cbData"]]
    ]
};

function getArgsString(args, argNames) {
    let result = {};
    for (let i = 0; i < argNames.length; i++) {
        try {
            result[argNames[i]] = args[i].readUtf16String() || args[i].toInt32();
        } catch (e) {
            result[argNames[i]] = "Unknown";
        }
    }
    return result;
}

for (const [category, apis] of Object.entries(INTERESTING_APIS)) {
    apis.forEach(([dll, func, argNames]) => {
        const funcPtr = Module.getExportByName(dll, func);
        if (funcPtr) {
            Interceptor.attach(funcPtr, {
                onEnter: function(args) {
                    this.category = category;
                    this.func = func;
                    this.args = getArgsString(args, argNames);
                },
                onLeave: function(retval) {
                    send({
                        type: "api_call",
                        category: this.category,
                        function: this.func,
                        arguments: this.args,
                        return_value: retval.toInt32()
                    });
                }
            });
        }
    });
}
"""

def on_frida_message(message: Dict[str, Any], data: Any) -> None:
    """Handle messages from Frida"""
    try:
        if message["type"] == "send":
            payload = message["payload"]
            if isinstance(payload, dict):
                if payload.get("type") == "api_call":
                    REPORT.add_system_activity(
                        payload["category"].lower().replace(" ", "_"),
                        {
                            "function": payload["function"],
                            "arguments": payload["arguments"],
                            "return_value": payload["return_value"],
                            "timestamp": datetime.now().isoformat()
                        }
                    )
                    logger.info(f"[API] {payload['category']} - {payload['function']}")
            else:
                logger.info(f"[Frida] {payload}")
                REPORT.add_system_activity("api_calls", {"raw": payload, "timestamp": datetime.now().isoformat()})
    except Exception as e:
        logger.error(f"Error processing Frida message: {e}")

def run_frida(pid: int) -> frida.core.Session:
    """Attach Frida to the target process"""
    try:
        device = frida.get_local_device()
        session = device.attach(pid)
        script = session.create_script(FRIDA_SCRIPT)
        script.on("message", on_frida_message)
        script.load()
        logger.info(f"Frida script loaded on PID {pid}")
        return session
    except Exception as e:
        logger.error(f"Frida attachment failed: {e}")
        raise

class MalwareRunner:
    def __init__(self, malware_path: str):
        self.malware_path = malware_path
        self.process = None
        self.sandbox_dir = self._create_sandbox()

    def _create_sandbox(self) -> str:
        """Create a sandbox directory for the malware"""
        sandbox_dir = os.path.join(os.getcwd(), "sandbox")
        os.makedirs(sandbox_dir, exist_ok=True)
        return sandbox_dir

    def run(self) -> subprocess.Popen:
        """Run the malware in a controlled environment"""
        try:
            env = os.environ.copy()
            env["TEMP"] = self.sandbox_dir
            env["TMP"] = self.sandbox_dir
            env["APPDATA"] = self.sandbox_dir
            
            creationflags = subprocess.CREATE_NEW_PROCESS_GROUP
            if os.name == 'nt':
                creationflags |= subprocess.DETACHED_PROCESS

            self.process = subprocess.Popen(
                [self.malware_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                env=env,
                cwd=self.sandbox_dir,
                creationflags=creationflags
            )
            logger.info(f"Started malware with PID {self.process.pid}")
            return self.process
        except Exception as e:
            logger.error(f"Failed to start malware: {e}")
            raise

    def terminate(self) -> None:
        """Terminate the malware process and its children"""
        if self.process:
            try:
                parent = psutil.Process(self.process.pid)
                children = parent.children(recursive=True)
                for child in children:
                    try:
                        child.terminate()
                    except psutil.NoSuchProcess:
                        pass
                parent.terminate()
                logger.info("Terminated malware process tree")
            except Exception as e:
                logger.error(f"Error terminating process: {e}")

def monitor_file_changes(sandbox_dir: str, interval: int = 5) -> None:
    """Monitor for file changes in the sandbox directory"""
    initial_files = set()
    try:
        for root, _, files in os.walk(sandbox_dir):
            for file in files:
                initial_files.add(os.path.join(root, file))

        while True:
            time.sleep(interval)
            current_files = set()
            for root, _, files in os.walk(sandbox_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    current_files.add(file_path)
                    if file_path not in initial_files:
                        file_info = {
                            "path": file_path,
                            "size": os.path.getsize(file_path),
                            "created": datetime.fromtimestamp(os.path.getctime(file_path)).isoformat(),
                            "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat(),
                            "timestamp": datetime.now().isoformat()
                        }
                        REPORT.add_system_activity("created_files", file_info)
                        logger.info(f"[File] Created: {file_path}")
                        initial_files.add(file_path)
    except Exception as e:
        logger.error(f"File monitoring error: {e}")

def get_process_tree(pid: int) -> List[Dict[str, Any]]:
    """Get the process tree starting from the given PID"""
    try:
        processes = []
        parent = psutil.Process(pid)
        processes.append({
            "pid": parent.pid,
            "name": parent.name(),
            "cmdline": parent.cmdline(),
            "status": parent.status(),
            "create_time": datetime.fromtimestamp(parent.create_time()).isoformat()
        })

        for child in parent.children(recursive=True):
            processes.append({
                "pid": child.pid,
                "name": child.name(),
                "cmdline": child.cmdline(),
                "status": child.status(),
                "create_time": datetime.fromtimestamp(child.create_time()).isoformat()
            })
        return processes
    except Exception as e:
        logger.error(f"Error getting process tree: {e}")
        return []

def main():
    MALWARE_PATH = "malware.exe"  # Replace with sample path
    ANALYSIS_DURATION = 30  # seconds
    
    try:
        REPORT.set_malware_path(MALWARE_PATH)
        
        # Start mitmproxy thread
        mitm_thread = threading.Thread(target=run_mitmproxy, daemon=True)
        mitm_thread.start()
        time.sleep(2)  # Give time for proxy to start

        # Start malware
        malware_runner = MalwareRunner(MALWARE_PATH)
        mal_proc = malware_runner.run()
        
        # Start file monitoring thread
        file_monitor_thread = threading.Thread(
            target=monitor_file_changes,
            args=(malware_runner.sandbox_dir,),
            daemon=True
        )
        file_monitor_thread.start()

        # Wait a moment for the process to start
        time.sleep(1)

        # Attach Frida
        try:
            frida_session = run_frida(mal_proc.pid)
        except Exception as e:
            logger.error(f"Frida attachment failed: {e}")
            malware_runner.terminate()
            return

        # Record process tree
        process_tree = get_process_tree(mal_proc.pid)
        REPORT.add_process_tree(process_tree)
        logger.info(f"Process tree recorded with {len(process_tree)} processes")

        # Monitor for the analysis duration
        logger.info(f"Monitoring for {ANALYSIS_DURATION} seconds...")
        start_time = time.time()
        while time.time() - start_time < ANALYSIS_DURATION:
            if mal_proc.poll() is not None:
                logger.warning("Malware process terminated early")
                break
            time.sleep(1)

    except KeyboardInterrupt:
        logger.info("Analysis interrupted by user")
    except Exception as e:
        logger.error(f"Analysis failed: {e}")
    finally:
        # Cleanup
        logger.info("Cleaning up...")
        malware_runner.terminate()
        if 'frida_session' in locals():
            frida_session.detach()
        
        # Collect final artifacts
        REPORT.add_artifact("sandbox_contents", {
            "directory": malware_runner.sandbox_dir,
            "files": list(os.listdir(malware_runner.sandbox_dir))
        })

        # Save report
        REPORT.save()

if __name__ == "__main__":
    main()
